"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapOutput = exports.mapInput = void 0;
/**
 * Map input chunk to a sequence of pending writes in the form [channel, value].
 */
function* mapInput(inputChannels, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
chunk
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (typeof inputChannels === "string") {
        yield [inputChannels, chunk];
    }
    else {
        if ((chunk && typeof chunk !== "object") || Array.isArray(chunk)) {
            throw new Error(`Expected chunk to be an object, got ${typeof chunk}`);
        }
        for (const k in chunk) {
            if (inputChannels.includes(k)) {
                yield [k, chunk[k]];
            }
            else {
                console.warn(`Input channel ${k} not found in ${inputChannels}`);
            }
        }
    }
}
exports.mapInput = mapInput;
/**
 * Map pending writes (a list of [channel, value]) to output chunk.
 */
function mapOutput(outputChannels, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
pendingWrites, channels
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (typeof outputChannels === "string") {
        if (pendingWrites.some(([chan, _]) => chan === outputChannels)) {
            return channels[outputChannels].get();
        }
    }
    else {
        const updated = pendingWrites
            .filter(([chan, _]) => outputChannels.includes(chan))
            .map(([chan, _]) => chan);
        if (updated.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return updated.reduce((acc, chan) => {
                acc[chan] = channels[chan].get();
                return acc;
            }, {});
        }
    }
    return undefined;
}
exports.mapOutput = mapOutput;
