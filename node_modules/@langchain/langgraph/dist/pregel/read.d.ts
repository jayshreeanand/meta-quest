import { Runnable, RunnableBinding, RunnableBindingArgs, RunnableConfig, RunnableEach, RunnableLambda, RunnableLike } from "@langchain/core/runnables";
import { ConfigurableFieldSpec } from "../checkpoint/index.js";
export declare class ChannelRead<RunInput = any, RunOutput = any> extends RunnableLambda<RunInput, RunOutput> {
    lc_graph_name: string;
    channel: string | Array<string>;
    constructor(channel: string | Array<string>);
    get configSpecs(): ConfigurableFieldSpec[];
    _read(_: any, config: RunnableConfig): any;
}
interface ChannelInvokeArgs<RunInput, RunOutput> extends Partial<RunnableBindingArgs<RunInput, RunOutput>> {
    channels: Record<string, string> | string;
    triggers: Array<string>;
    when?: (args: any) => boolean;
    config?: RunnableConfig;
    tags?: string[];
}
export type ChannelInvokeInputType = any;
export type ChannelInvokeOutputType = any;
export declare class ChannelInvoke<RunInput = ChannelInvokeInputType, RunOutput = ChannelInvokeOutputType> extends RunnableBinding<RunInput, RunOutput, RunnableConfig> {
    lc_graph_name: string;
    channels: Record<string, string> | string;
    triggers: string[];
    when?: (args: any) => boolean;
    constructor(fields: ChannelInvokeArgs<RunInput, RunOutput>);
    join(channels: Array<string>): ChannelInvoke<RunInput, RunOutput>;
    pipe<NewRunOutput>(coerceable: RunnableLike): ChannelInvoke<RunInput, Exclude<NewRunOutput, Error>>;
}
interface ChannelBatchArgs {
    channel: string;
    key?: string;
    bound?: Runnable;
}
export type ChannelBatchInputType = any;
export type ChannelBatchOutputType = any;
export declare class ChannelBatch extends RunnableEach<ChannelBatchInputType, ChannelBatchOutputType, RunnableConfig> {
    lc_graph_name: string;
    channel: string;
    key?: string;
    constructor(fields: ChannelBatchArgs);
    join(channels: Array<string>): ChannelBatch;
    pipe(coerceable: RunnableLike): ChannelBatch;
}
export {};
