import { Checkpoint } from "../checkpoint/index.js";
export declare abstract class BaseChannel<Value = unknown, Update = unknown, C = unknown> {
    /**
     * The name of the channel.
     */
    abstract lc_graph_name: string;
    /**
     * Return a new identical channel, optionally initialized from a checkpoint.
     *
     * @param {C | undefined} checkpoint
     * @param {C | undefined} initialValue
     * @returns {this}
     */
    abstract empty(checkpoint?: C, initialValueFactory?: () => C): BaseChannel<Value, Update, C>;
    /**
     * Update the channel's value with the given sequence of updates.
     * The order of the updates in the sequence is arbitrary.
     *
     * @throws {InvalidUpdateError} if the sequence of updates is invalid.
     * @param {Array<Update>} values
     * @returns {void}
     */
    abstract update(values: Update[]): void;
    /**
     * Return the current value of the channel.
     *
     * @throws {EmptyChannelError} if the channel is empty (never updated yet).
     * @returns {Value}
     */
    abstract get(): Value;
    /**
     * Return a string representation of the channel's current state.
     *
     * @throws {EmptyChannelError} if the channel is empty (never updated yet), or doesn't support checkpoints.
     * @returns {C | undefined}
     */
    abstract checkpoint(): C | undefined;
}
export declare class EmptyChannelError extends Error {
    constructor(message?: string);
}
export declare class InvalidUpdateError extends Error {
    constructor(message?: string);
}
export declare function emptyChannels(channels: Record<string, BaseChannel>, checkpoint: Checkpoint): Record<string, BaseChannel>;
export declare function createCheckpoint<Value>(checkpoint: Checkpoint, channels: Record<string, BaseChannel<Value>>): Promise<Checkpoint>;
