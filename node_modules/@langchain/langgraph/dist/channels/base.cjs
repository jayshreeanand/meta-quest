"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCheckpoint = exports.emptyChannels = exports.InvalidUpdateError = exports.EmptyChannelError = exports.BaseChannel = void 0;
class BaseChannel {
}
exports.BaseChannel = BaseChannel;
class EmptyChannelError extends Error {
    constructor(message) {
        super(message);
        this.name = "EmptyChannelError";
    }
}
exports.EmptyChannelError = EmptyChannelError;
class InvalidUpdateError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidUpdateError";
    }
}
exports.InvalidUpdateError = InvalidUpdateError;
function emptyChannels(channels, checkpoint) {
    const newChannels = {};
    for (const k in channels) {
        if (Object.prototype.hasOwnProperty.call(channels, k)) {
            const channelValue = checkpoint.channelValues[k];
            newChannels[k] = channels[k].empty(channelValue);
        }
    }
    return newChannels;
}
exports.emptyChannels = emptyChannels;
async function createCheckpoint(checkpoint, channels) {
    const newCheckpoint = {
        v: 1,
        ts: new Date().toISOString(),
        channelValues: { ...checkpoint.channelValues },
        channelVersions: { ...checkpoint.channelVersions },
        versionsSeen: { ...checkpoint.versionsSeen },
    };
    for (const k in channels) {
        if (newCheckpoint.channelValues[k] === undefined) {
            try {
                newCheckpoint.channelValues[k] = await channels[k].checkpoint();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                if ("name" in error && error.name === EmptyChannelError.name) {
                    // no-op
                }
                else {
                    throw error; // Rethrow unexpected errors
                }
            }
        }
    }
    return newCheckpoint;
}
exports.createCheckpoint = createCheckpoint;
