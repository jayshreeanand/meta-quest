"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateGraph = exports.START = void 0;
const runnables_1 = require("@langchain/core/runnables");
const binop_js_1 = require("../channels/binop.cjs");
const graph_js_1 = require("./graph.cjs");
const last_value_js_1 = require("../channels/last_value.cjs");
const write_js_1 = require("../pregel/write.cjs");
const index_js_1 = require("../pregel/index.cjs");
const read_js_1 = require("../pregel/read.cjs");
exports.START = "__start__";
class StateGraph extends graph_js_1.Graph {
    constructor(fields) {
        super();
        Object.defineProperty(this, "channels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.channels = _getChannels(fields.channels);
    }
    addNode(key, action) {
        if (Object.keys(this.nodes).some((key) => key in this.channels)) {
            throw new Error(`${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);
        }
        super.addNode(key, action);
    }
    compile(checkpointer) {
        this.validate();
        if (Object.keys(this.nodes).some((key) => key in this.channels)) {
            throw new Error("Cannot use channel names as node names");
        }
        const stateKeys = Object.keys(this.channels);
        const stateKeysRead = stateKeys.length === 1 && stateKeys[0] === "__root__"
            ? stateKeys[0]
            : stateKeys;
        const updateState = Array.isArray(stateKeysRead)
            ? (nodeName, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            input, options) => _updateStateObject(stateKeys, nodeName, input, options)
            : _updateStateRoot;
        const outgoingEdges = {};
        for (const [start, end] of this.edges) {
            if (!outgoingEdges[start]) {
                outgoingEdges[start] = [];
            }
            outgoingEdges[start].push(end !== graph_js_1.END ? `${end}:inbox` : graph_js_1.END);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const nodes = {};
        for (const [key, node] of Object.entries(this.nodes)) {
            nodes[key] = index_js_1.Channel.subscribeTo(`${key}:inbox`)
                .pipe(node)
                .pipe((
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            input, options) => updateState(key, input, options))
                .pipe(index_js_1.Channel.writeTo(key));
        }
        for (const key of Object.keys(this.nodes)) {
            const outgoing = outgoingEdges[key];
            const edgesKey = `${key}:edges`;
            if (outgoing || this.branches[key]) {
                nodes[edgesKey] = index_js_1.Channel.subscribeTo(key, {
                    tags: ["langsmith:hidden"],
                }).pipe(new read_js_1.ChannelRead(stateKeysRead));
            }
            if (outgoing) {
                nodes[edgesKey] = nodes[edgesKey].pipe(index_js_1.Channel.writeTo(...outgoing));
            }
            if (this.branches[key]) {
                for (const branch of this.branches[key]) {
                    nodes[edgesKey] = nodes[edgesKey].pipe(new runnables_1.RunnableLambda({
                        func: (i, c) => branch.runnable(i, c),
                    }));
                }
            }
        }
        nodes[exports.START] = index_js_1.Channel.subscribeTo(`${exports.START}:inbox`, {
            tags: ["langsmith:hidden"],
        })
            .pipe((
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        input, options) => updateState(exports.START, input, options))
            .pipe(index_js_1.Channel.writeTo(exports.START));
        nodes[`${exports.START}:edges`] = index_js_1.Channel.subscribeTo(exports.START, {
            tags: ["langsmith:hidden"],
        })
            .pipe(new read_js_1.ChannelRead(stateKeysRead))
            .pipe(index_js_1.Channel.writeTo(`${this.entryPoint}:inbox`));
        return new index_js_1.Pregel({
            nodes,
            channels: this.channels,
            input: `${exports.START}:inbox`,
            output: graph_js_1.END,
            hidden: Object.keys(this.nodes)
                .map((node) => `${node}:inbox`)
                .concat(exports.START, stateKeys),
            checkpointer,
        });
    }
}
exports.StateGraph = StateGraph;
function _updateStateObject(stateKeys, nodeName, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
input, options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (!options?.config) {
        throw new Error("Config not found when updating state.");
    }
    if (Object.keys(input).some((key) => !stateKeys.some((sk) => sk === key))) {
        throw new Error(`Invalid state update from node ${nodeName}, expected object with one or more of ${stateKeys.join(", ")}, got ${Object.keys(input).join(",")}`);
    }
    write_js_1.ChannelWrite.doWrite(options.config, input);
    return input;
}
function _updateStateRoot(_nodeName, input, options) {
    if (!options?.config) {
        throw new Error("Config not found when updating state.");
    }
    write_js_1.ChannelWrite.doWrite(options.config, {
        __root__: input,
    });
    return input;
}
function _getChannels(schema) {
    if ("value" in schema && "default" in schema) {
        if (!schema.value) {
            throw new Error("Value is required for channels");
        }
        return {
            __root__: new binop_js_1.BinaryOperatorAggregate(schema.value, schema.default),
        };
    }
    const channels = {};
    for (const [name, values] of Object.entries(schema)) {
        if (values.value) {
            channels[name] = new binop_js_1.BinaryOperatorAggregate(values.value, values.default);
        }
        else {
            channels[name] = new last_value_js_1.LastValue();
        }
    }
    return channels;
}
