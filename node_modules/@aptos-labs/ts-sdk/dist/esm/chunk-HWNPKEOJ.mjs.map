{"version":3,"sources":["../../src/transactions/transactionBuilder/transactionBuilder.ts","../../src/transactions/scriptComposer/index.ts","../../src/internal/transactionSubmission.ts","../../src/internal/account.ts","../../src/transactions/transactionBuilder/remoteAbi.ts"],"sourcesContent":["// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput, Hex, PublicKey } from \"../../core\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  Secp256k1PublicKey,\n  FederatedKeylessPublicKey,\n  MultiKey,\n  MultiKeySignature,\n} from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { getInfo } from \"../../internal/utils\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport { DEFAULT_MAX_GAS_AMOUNT, DEFAULT_TXN_EXP_SEC_FROM_NOW } from \"../../utils/const\";\nimport { normalizeBundle } from \"../../utils/normalizeBundle\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorNoAccountAuthenticator,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticator,\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorMultiEd25519,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultiSig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  AnyRawTransaction,\n  AnyTransactionPayloadInstance,\n  EntryFunctionArgumentTypes,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  InputGenerateTransactionOptions,\n  InputScriptData,\n  InputSimulateTransactionData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateTransactionPayloadDataWithABI,\n  InputEntryFunctionDataWithABI,\n  InputMultiSigDataWithABI,\n  InputViewFunctionDataWithRemoteABI,\n  InputViewFunctionDataWithABI,\n  FunctionABI,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, fetchViewFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { isScriptDataInput } from \"./helpers\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../instances/multiAgentTransaction\";\nimport { getFunctionParts } from \"../../utils/helpers\";\n\n/**\n * Builds a transaction payload based on the provided arguments and returns a transaction payload.\n * This function uses the RemoteABI by default, but can also utilize a specified ABI.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @param args - The input data for generating the transaction payload.\n * @param args.function - The function to be called, specified in the format \"moduleAddress::moduleName::functionName\".\n * @param args.functionArguments - The arguments to pass to the function.\n * @param args.typeArguments - The type arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.abi - The ABI to use for the transaction, if not using the RemoteABI.\n *\n * @returns TransactionPayload - The generated transaction payload, which can be of type TransactionPayloadScript,\n * TransactionPayloadMultiSig, or TransactionPayloadEntryFunction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(args: InputScriptData): Promise<TransactionPayloadScript>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultiSig>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultiSig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"entry-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchEntryFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateTransactionPayloadWithABI({ ...args, abi: functionAbi });\n}\n\n/**\n * Generates a transaction payload using the provided ABI and function details.\n * This function helps create a properly structured transaction payload for executing a specific function on a module.\n *\n * @param args - The input data required to generate the transaction payload.\n * @param args.abi - The ABI of the function to be executed.\n * @param args.function - The fully qualified name of the function in the format `moduleAddress::moduleName::functionName`.\n * @param args.typeArguments - An array of type arguments that correspond to the function's type parameters.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n * @param args.multisigAddress - (Optional) The address for a multisig transaction if applicable.\n *\n * @throws Error if the type argument count does not match the ABI or if the number of function arguments is incorrect.\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputEntryFunctionDataWithABI): TransactionPayloadEntryFunction;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputMultiSigDataWithABI): TransactionPayloadMultiSig;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadDataWithABI,\n): AnyTransactionPayloadInstance {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    /**\n     * Converts the argument for a specified function using its ABI and type arguments.\n     * This function helps ensure that the correct number of arguments is provided for the function call.\n     *\n     * @param args - The arguments for the function call.\n     * @param args.function - The specific function to be invoked.\n     * @param functionAbi - The ABI (Application Binary Interface) of the function, which includes parameter details.\n     * @param arg - The argument to be converted.\n     * @param i - The index of the argument in the function call.\n     * @param typeArguments - Additional type arguments that may be required for the conversion.\n     * @group Implementation\n     * @category Transactions\n     */\n    // TODO: Fix JSDoc\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    const multisigAddress = AccountAddress.from(args.multisigAddress);\n    return new TransactionPayloadMultiSig(\n      new MultiSig(multisigAddress, new MultiSigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\n/**\n * Generates the payload for a view function call using the provided arguments.\n * This function helps in preparing the necessary data to interact with a specific view function on the blockchain.\n *\n * @param args - The input data required to generate the view function payload.\n * @param args.function - The function identifier in the format \"moduleAddress::moduleName::functionName\".\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.abi - The ABI (Application Binary Interface) of the module.\n *\n * @returns The generated payload for the view function call.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateViewFunctionPayload(args: InputViewFunctionDataWithRemoteABI): Promise<EntryFunction> {\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"view-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchViewFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateViewFunctionPayloadWithABI({ abi: functionAbi, ...args });\n}\n\n/**\n * Generates a payload for a view function call using the provided ABI and arguments.\n * This function ensures that the type arguments and function arguments are correctly formatted\n * and match the expected counts as defined in the ABI.\n *\n * @param args - The input data for generating the view function payload.\n * @param args.abi - The ABI of the function to be called.\n * @param args.function - The full name of the function in the format \"moduleAddress::moduleName::functionName\".\n * @param args.typeArguments - An array of type arguments to be used in the function call.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n *\n * @throws Error if the type argument count does not match the ABI or if the function arguments\n * do not match the expected parameters defined in the ABI.\n * @group Implementation\n * @category Transactions\n */\nexport function generateViewFunctionPayloadWithABI(args: InputViewFunctionDataWithABI): EntryFunction {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> =\n    args?.functionArguments?.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)) ?? [];\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  return EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n}\n\n/**\n * Generates a transaction payload script based on the provided input data.\n * This function helps in creating a structured script for transaction processing.\n *\n * @param args - The input data required to generate the transaction payload script.\n * @param args.bytecode - The bytecode to be converted into a Uint8Array.\n * @param args.typeArguments - The type arguments that will be standardized.\n * @param args.functionArguments - The arguments for the function being called.\n * @returns A new instance of TransactionPayloadScript.\n * @group Implementation\n * @category Transactions\n */\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(\n      Hex.fromHexInput(args.bytecode).toUint8Array(),\n      standardizeTypeTags(args.typeArguments),\n      args.functionArguments,\n    ),\n  );\n}\n\n/**\n * Generates a raw transaction that can be sent to the Aptos network.\n *\n * @param args - The arguments for generating the raw transaction.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using generateTransactionPayload().\n * @param args.options - Optional parameters for transaction generation.\n * @param args.feePayerAddress - The address of the fee payer for sponsored transactions.\n *\n * @returns RawTransaction - The generated raw transaction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n  feePayerAddress?: AccountAddressInput;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n\n  const getChainId = async () => {\n    if (NetworkToChainId[aptosConfig.network]) {\n      return { chainId: NetworkToChainId[aptosConfig.network] };\n    }\n    const info = await getLedgerInfo({ aptosConfig });\n    return { chainId: info.chain_id };\n  };\n\n  const getGasUnitPrice = async () => {\n    if (options?.gasUnitPrice) {\n      return { gasEstimate: options.gasUnitPrice };\n    }\n    const estimation = await getGasPriceEstimation({ aptosConfig });\n    return { gasEstimate: estimation.gas_estimate };\n  };\n\n  const getSequenceNumberForAny = async () => {\n    const getSequenceNumber = async () => {\n      if (options?.accountSequenceNumber !== undefined) {\n        return options.accountSequenceNumber;\n      }\n\n      return (await getInfo({ aptosConfig, accountAddress: sender })).sequence_number;\n    };\n\n    /**\n     * Check if is sponsored transaction to honor AIP-52\n     * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-52.md}\n     * @group Implementation\n     * @category Transactions\n     */\n    if (feePayerAddress && AccountAddress.from(feePayerAddress).equals(AccountAddress.ZERO)) {\n      // Handle sponsored transaction generation with the option that\n      // the main signer has not been created on chain\n      try {\n        // Check if main signer has been created on chain, if not assign sequence number 0\n        return await getSequenceNumber();\n      } catch (e: any) {\n        return 0;\n      }\n    } else {\n      return getSequenceNumber();\n    }\n  };\n  const [{ chainId }, { gasEstimate }, sequenceNumber] = await Promise.all([\n    getChainId(),\n    getGasUnitPrice(),\n    getSequenceNumberForAny(),\n  ]);\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {\n    maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: options?.gasUnitPrice ?? BigInt(gasEstimate),\n    expireTimestamp: options?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1000) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n  };\n\n  return new RawTransaction(\n    AccountAddress.from(sender),\n    BigInt(sequenceNumber),\n    payload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\n/**\n * Generates a transaction based on the provided arguments.\n * This function can create both simple and multi-agent transactions, allowing for flexible transaction handling.\n *\n * @param args - The input arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using `generateTransactionPayload()`.\n * @param args.options - Optional. Transaction options object.\n * @param args.secondarySignerAddresses - Optional. An array of addresses for additional signers in a multi-signature transaction.\n * @param args.feePayerAddress - Optional. The address of the fee payer for sponsored transactions.\n * @returns An instance of a transaction, which may include secondary signer addresses and a fee payer address.\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateSingleSignerRawTransactionArgs): Promise<SimpleTransaction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateMultiAgentRawTransactionArgs): Promise<MultiAgentTransaction>;\n\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n\n  // if multi agent transaction\n  if (\"secondarySignerAddresses\" in args) {\n    const signers: Array<AccountAddress> =\n      args.secondarySignerAddresses?.map((signer) => AccountAddress.from(signer)) ?? [];\n\n    return new MultiAgentTransaction(\n      rawTxn,\n      signers,\n      args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n    );\n  }\n  // return the raw transaction\n  return new SimpleTransaction(rawTxn, args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined);\n}\n\n/**\n * Generate a signed transaction for simulation before submitting it to the chain.\n * This function helps in preparing a transaction that can be simulated, allowing users to verify its validity and expected behavior.\n *\n * @param args - The input data required to generate the signed transaction for simulation.\n * @param args.transaction - An Aptos transaction type to sign.\n * @param args.signerPublicKey - The public key of the signer.\n * @param args.secondarySignersPublicKeys - Optional. The public keys of secondary signers if it is a multi-signer transaction.\n * @param args.feePayerPublicKey - Optional. The public key of the fee payer in a sponsored transaction.\n * @param args.options - Optional. Additional options for simulating the transaction.\n *\n * @returns A signed serialized transaction that can be simulated.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (transaction.secondarySignerAddresses) {\n      if (secondarySignersPublicKeys) {\n        secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n          getAuthenticatorForSimulation(publicKey),\n        );\n      } else {\n        secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n          getAuthenticatorForSimulation(undefined),\n        );\n      }\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    } else {\n      secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n        getAuthenticatorForSimulation(undefined),\n      );\n    }\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // single signer raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (\n    accountAuthenticator instanceof AccountAuthenticatorSingleKey ||\n    accountAuthenticator instanceof AccountAuthenticatorMultiKey\n  ) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorNoAccountAuthenticator) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();\n}\n\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function getAuthenticatorForSimulation(publicKey?: PublicKey) {\n  if (!publicKey) {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n\n  // Wrap the public key types below with AnyPublicKey as they are only support through single sender.\n  // Learn more about AnyPublicKey here - https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md\n  const convertToAnyPublicKey =\n    KeylessPublicKey.isInstance(publicKey) ||\n    FederatedKeylessPublicKey.isInstance(publicKey) ||\n    Secp256k1PublicKey.isInstance(publicKey);\n  const accountPublicKey = convertToAnyPublicKey ? new AnyPublicKey(publicKey) : publicKey;\n\n  // No need to for the signature to be matching in scheme. All that matters for simulations is that it's not valid\n  const invalidSignature = new Ed25519Signature(new Uint8Array(64));\n\n  if (Ed25519PublicKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorEd25519(accountPublicKey, invalidSignature);\n  }\n\n  if (AnyPublicKey.isInstance(accountPublicKey)) {\n    if (KeylessPublicKey.isInstance(accountPublicKey.publicKey)) {\n      return new AccountAuthenticatorSingleKey(\n        accountPublicKey,\n        new AnySignature(KeylessSignature.getSimulationSignature()),\n      );\n    }\n    return new AccountAuthenticatorSingleKey(accountPublicKey, new AnySignature(invalidSignature));\n  }\n\n  if (MultiKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorMultiKey(\n      accountPublicKey,\n      new MultiKeySignature({\n        signatures: accountPublicKey.publicKeys.map((pubKey) => {\n          if (KeylessPublicKey.isInstance(pubKey.publicKey) || FederatedKeylessPublicKey.isInstance(pubKey.publicKey)) {\n            return new AnySignature(KeylessSignature.getSimulationSignature());\n          }\n          return new AnySignature(invalidSignature);\n        }),\n        bitmap: accountPublicKey.createBitmap({\n          bits: Array(accountPublicKey.publicKeys.length)\n            .fill(0)\n            .map((_, i) => i),\n        }),\n      }),\n    );\n  }\n\n  throw new Error(\"Unsupported PublicKey used for simulations\");\n}\n\n/**\n * Generate a signed transaction ready for submission to the blockchain.\n * This function prepares the transaction by authenticating the sender and any additional signers based on the provided arguments.\n *\n * @param args - The input data required to generate the signed transaction.\n * @param args.transaction - An Aptos transaction type containing the details of the transaction.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.feePayerAuthenticator - The authenticator for the fee payer, required if the transaction has a fee payer address.\n * @param args.additionalSignersAuthenticators - Optional authenticators for additional signers in a multi-signer transaction.\n *\n * @returns A Uint8Array representing the signed transaction in bytes.\n *\n * @throws Error if the feePayerAuthenticator is not provided for a fee payer transaction.\n * @throws Error if additionalSignersAuthenticators are not provided for a multi-signer transaction.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransaction(args: InputSubmitTransactionData): Uint8Array {\n  const { transaction, feePayerAuthenticator, additionalSignersAuthenticators } = args;\n  const senderAuthenticator = normalizeBundle(AccountAuthenticator, args.senderAuthenticator);\n\n  let txnAuthenticator: TransactionAuthenticator;\n  if (transaction.feePayerAddress) {\n    if (!feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    txnAuthenticator = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n  } else if (transaction.secondarySignerAddresses) {\n    if (!additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    txnAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses,\n      additionalSignersAuthenticators,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorMultiEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorMultiEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else {\n    txnAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n  }\n\n  return new SignedTransaction(transaction.rawTransaction, txnAuthenticator).bcsToBytes();\n}\n\n/**\n * Hashes the set of values using a SHA-3 256 hash algorithm.\n * @param input - An array of UTF-8 strings or Uint8Array byte arrays to be hashed.\n * @group Implementation\n * @category Transactions\n */\nexport function hashValues(input: (Uint8Array | string)[]): Uint8Array {\n  const hash = sha3Hash.create();\n  for (const item of input) {\n    hash.update(item);\n  }\n  return hash.digest();\n}\n\n/**\n * The domain separated prefix for hashing transactions\n * @group Implementation\n * @category Transactions\n */\nconst TRANSACTION_PREFIX = hashValues([\"APTOS::Transaction\"]);\n\n/**\n * Generates a user transaction hash for the provided transaction payload, which must already have an authenticator.\n * This function helps ensure the integrity and uniqueness of the transaction by producing a hash based on the signed transaction data.\n *\n * @param args - The input data required to submit the transaction.\n * @param args.authenticator - The authenticator for the transaction.\n * @param args.payload - The payload containing the transaction details.\n * @param args.sender - The address of the sender initiating the transaction.\n * @param args.sequenceNumber - The sequence number of the transaction for the sender.\n * @group Implementation\n * @category Transactions\n */\nexport function generateUserTransactionHash(args: InputSubmitTransactionData): string {\n  const signedTransaction = generateSignedTransaction(args);\n\n  // Transaction signature is defined as, the domain separated prefix based on struct (Transaction)\n  // Then followed by the type of the transaction for the enum, UserTransaction is 0\n  // Then followed by BCS encoded bytes of the signed transaction\n  return new Hex(hashValues([TRANSACTION_PREFIX, new Uint8Array([0]), signedTransaction])).toString();\n}\n\n/**\n * Fetches and caches ABIs while allowing for pass-through on provided ABIs.\n *\n * @param key - A unique identifier for the cached ABI.\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is being fetched.\n * @param aptosConfig - Configuration settings for Aptos.\n * @param abi - An optional ABI to use if already available.\n * @param fetch - A function to fetch the ABI if it is not provided.\n * @group Implementation\n * @category Transactions\n */\nasync function fetchAbi<T extends FunctionABI>({\n  key,\n  moduleAddress,\n  moduleName,\n  functionName,\n  aptosConfig,\n  abi,\n  fetch,\n}: {\n  key: string;\n  moduleAddress: string;\n  moduleName: string;\n  functionName: string;\n  aptosConfig: AptosConfig;\n  abi?: T;\n  fetch: (moduleAddress: string, moduleName: string, functionName: string, aptosConfig: AptosConfig) => Promise<T>;\n}): Promise<T> {\n  if (abi !== undefined) {\n    return abi;\n  }\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  return memoizeAsync(\n    async () => fetch(moduleAddress, moduleName, functionName, aptosConfig),\n    `${key}-${aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ScriptComposerWasm } from \"@aptos-labs/script-composer-pack\";\nimport { AptosApiType, getFunctionParts } from \"../../utils\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { InputBatchedFunctionData } from \"../types\";\nimport { standardizeTypeTags } from \"../transactionBuilder\";\nimport { CallArgument } from \"../../types\";\nimport { convertArgument, fetchModuleAbi } from \"../transactionBuilder/remoteAbi\";\n\n/**\n * A wrapper class around TransactionComposer, which is a WASM library compiled\n * from aptos-core/aptos-move/script-composer.\n * This class allows the SDK caller to build a transaction that invokes multiple Move functions\n * and allow for arguments to be passed around.\n * */\nexport class AptosScriptComposer {\n  private config: AptosConfig;\n\n  private builder?: any;\n\n  private static transactionComposer?: any;\n\n  constructor(aptosConfig: AptosConfig) {\n    this.config = aptosConfig;\n    this.builder = undefined;\n  }\n\n  // Initializing the wasm needed for the script composer, must be called\n  // before using the composer.\n  async init() {\n    if (!AptosScriptComposer.transactionComposer) {\n      const module = await import(\"@aptos-labs/script-composer-pack\");\n      const { TransactionComposer, initSync } = module;\n      if (!ScriptComposerWasm.isInitialized) {\n        ScriptComposerWasm.init();\n      }\n      initSync({ module: ScriptComposerWasm.wasm });\n      AptosScriptComposer.transactionComposer = TransactionComposer;\n    }\n    this.builder = AptosScriptComposer.transactionComposer.single_signer();\n  }\n\n  // Add a move function invocation to the TransactionComposer.\n  //\n  // Similar to how to create an entry function, the difference is that input arguments could\n  // either be a `CallArgument` which represents an abstract value returned from a previous Move call\n  // or the regular entry function arguments.\n  //\n  // The function would also return a list of `CallArgument` that can be passed on to future calls.\n  async addBatchedCalls(input: InputBatchedFunctionData): Promise<CallArgument[]> {\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(input.function);\n    const nodeUrl = this.config.getRequestUrl(AptosApiType.FULLNODE);\n\n    // Load the calling module into the builder.\n    await this.builder.load_module(nodeUrl, `${moduleAddress}::${moduleName}`);\n\n    // Load the calling type arguments into the loader.\n    if (input.typeArguments !== undefined) {\n      for (const typeArgument of input.typeArguments) {\n        await this.builder.load_type_tag(nodeUrl, typeArgument.toString());\n      }\n    }\n    const typeArguments = standardizeTypeTags(input.typeArguments);\n    const moduleAbi = await fetchModuleAbi(moduleAddress, moduleName, this.config);\n    if (!moduleAbi) {\n      throw new Error(`Could not find module ABI for '${moduleAddress}::${moduleName}'`);\n    }\n\n    // Check the type argument count against the ABI\n    const functionAbi = moduleAbi?.exposed_functions.find((func) => func.name === functionName);\n    if (!functionAbi) {\n      throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n    }\n\n    if (typeArguments.length !== functionAbi.generic_type_params.length) {\n      throw new Error(\n        `Type argument count mismatch, expected ${functionAbi?.generic_type_params.length}, received ${typeArguments.length}`,\n      );\n    }\n\n    const functionArguments: CallArgument[] = input.functionArguments.map((arg, i) =>\n      arg instanceof CallArgument\n        ? arg\n        : CallArgument.newBytes(\n            convertArgument(functionName, moduleAbi, arg, i, typeArguments, { allowUnknownStructs: true }).bcsToBytes(),\n          ),\n    );\n\n    return this.builder.add_batched_call(\n      `${moduleAddress}::${moduleName}`,\n      functionName,\n      typeArguments.map((arg) => arg.toString()),\n      functionArguments,\n    );\n  }\n\n  build(): Uint8Array {\n    return this.builder.generate_batched_calls(true);\n  }\n}\n","/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Deserializer, MoveVector } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account, AbstractKeylessAccount, isKeylessSigner } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { FederatedKeylessPublicKey, KeylessPublicKey, KeylessSignature } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n} from \"../transactions/types\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput } from \"../types\";\nimport { SignedTransaction, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\n/**\n * Builds a transaction payload based on the provided configuration and input data.\n * This function is essential for preparing transaction data for execution on the Aptos blockchain.\n *\n * @param args - The arguments for building the transaction payload.\n * @param args.aptosConfig - Configuration settings for the Aptos network.\n * @param args.data - Input data required to generate the transaction payload, which may include bytecode, multisig address,\n * function name, function arguments, type arguments, and ABI.\n * @returns A promise that resolves to the generated transaction payload instance.\n * @group Implementation\n */\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\n/**\n * Builds a raw transaction based on the provided configuration and payload.\n * This function helps in creating a transaction that can be sent to the Aptos blockchain.\n *\n * @param args - The arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The address of the sender of the transaction.\n * @param args.options - Additional options for the transaction.\n * @param payload - The payload of the transaction, which defines the action to be performed.\n * @group Implementation\n */\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\n/**\n * Determine if the transaction input includes a fee payer.\n *\n * @param data - The input data for generating a transaction.\n * @param data.withFeePayer - Indicates whether a fee payer is included in the transaction input.\n * @returns A boolean value indicating if the transaction input has a fee payer.\n * @group Implementation\n */\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\n/**\n * Determines whether the provided transaction input data includes multiple agent signatures.\n *\n * @param data - The transaction input data to evaluate.\n * @param data.secondarySignerAddresses - An array of secondary signer addresses, indicating multiple agents.\n * @group Implementation\n */\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers.\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK.\n *\n * @param args - The arguments for generating the signing message.\n * @param args.transaction - AnyRawTransaction, as generated by `generateTransaction()`.\n *\n * @returns The message to be signed.\n * @group Implementation\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to the chain.\n *\n * @param args The arguments for signing the transaction.\n * @param args.signer The signer account to sign the transaction.\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n *\n * @return The signer AccountAuthenticator.\n * @group Implementation\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\nexport function signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  // if transaction doesn't hold a \"feePayerAddress\" prop it means\n  // this is not a fee payer transaction\n  if (!transaction.feePayerAddress) {\n    throw new Error(`Transaction ${transaction} is not a Fee Payer transaction`);\n  }\n\n  // Set the feePayerAddress to the signer account address\n  transaction.feePayerAddress = signer.accountAddress;\n\n  return signTransaction({\n    signer,\n    transaction,\n  });\n}\n\n/**\n * Simulates a transaction before signing it to evaluate its potential outcome.\n *\n * @param args The arguments for simulating the transaction.\n * @param args.aptosConfig The configuration for the Aptos network.\n * @param args.transaction The raw transaction to simulate.\n * @param args.signerPublicKey Optional. The signer public key.\n * @param args.secondarySignersPublicKeys Optional. For when the transaction involves multiple signers.\n * @param args.feePayerPublicKey Optional. For when the transaction is sponsored by a fee payer.\n * @param args.options Optional. A configuration object to customize the simulation process.\n * @param args.options.estimateGasUnitPrice Optional. Indicates whether to estimate the gas unit price.\n * @param args.options.estimateMaxGasAmount Optional. Indicates whether to estimate the maximum gas amount.\n * @param args.options.estimatePrioritizedGasUnitPrice Optional. Indicates whether to estimate the prioritized gas unit price.\n * @group Implementation\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit a transaction to the Aptos blockchain.\n *\n * @param args - The arguments for submitting the transaction.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.transaction - The Aptos transaction data to be submitted.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.\n *\n * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.\n * @group Implementation\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  try {\n    const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n      aptosConfig,\n      body: signedTransaction,\n      path: \"transactions\",\n      originMethod: \"submitTransaction\",\n      contentType: MimeType.BCS_SIGNED_TRANSACTION,\n    });\n    return data;\n  } catch (e) {\n    const signedTxn = SignedTransaction.deserialize(new Deserializer(signedTransaction));\n    if (\n      signedTxn.authenticator.isSingleSender() &&\n      signedTxn.authenticator.sender.isSingleKey() &&\n      (signedTxn.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey ||\n        signedTxn.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)\n    ) {\n      await AbstractKeylessAccount.fetchJWK({\n        aptosConfig,\n        publicKey: signedTxn.authenticator.sender.public_key.publicKey,\n        kid: (signedTxn.authenticator.sender.signature.signature as KeylessSignature).getJwkKid(),\n      });\n    }\n    throw e;\n  }\n}\n\nexport type FeePayerOrFeePayerAuthenticatorOrNeither =\n  | { feePayer: Account; feePayerAuthenticator?: never }\n  | { feePayer?: never; feePayerAuthenticator: AccountAuthenticator }\n  | { feePayer?: never; feePayerAuthenticator?: never };\n\nexport async function signAndSubmitTransaction(\n  args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n    aptosConfig: AptosConfig;\n    signer: Account;\n    transaction: AnyRawTransaction;\n  },\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, feePayer, transaction } = args;\n  // If the signer contains a KeylessAccount, await proof fetching in case the proof\n  // was fetched asynchronously.\n  if (isKeylessSigner(signer)) {\n    await signer.checkKeylessAccountValidity(aptosConfig);\n  }\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n  const feePayerAuthenticator =\n    args.feePayerAuthenticator || (feePayer && signAsFeePayer({ signer: feePayer, transaction }));\n\n  const senderAuthenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nexport async function signAndSubmitAsFeePayer(args: {\n  aptosConfig: AptosConfig;\n  feePayer: Account;\n  senderAuthenticator: AccountAuthenticator;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, senderAuthenticator, feePayer, transaction } = args;\n\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n\n  const feePayerAuthenticator = signAsFeePayer({ signer: feePayer, transaction });\n\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\n/**\n * Publishes a package transaction to the Aptos blockchain.\n * This function allows you to create and send a transaction that publishes a package with the specified metadata and bytecode.\n *\n * @param args - The arguments for the package transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.account - The address of the account sending the transaction.\n * @param args.metadataBytes - The metadata associated with the package, represented as hexadecimal input.\n * @param args.moduleBytecode - An array of module bytecode, each represented as hexadecimal input.\n * @param args.options - Optional parameters for generating the transaction.\n * @group Implementation\n */\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, paginateWithCursor, paginateWithObfuscatedCursor } from \"../client\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account, Ed25519Account, MultiEd25519Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport { getModules as getModulesUtil, getModule as getModuleUtil, getInfo as getInfoUtil } from \"./utils\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\nimport { signAndSubmitTransaction, generateTransaction } from \"./transactionSubmission\";\nimport { EntryFunctionABI, RotationProofChallenge, TypeTagU8, TypeTagVector } from \"../transactions\";\nimport { U8, MoveVector } from \"../bcs\";\nimport { waitForTransaction } from \"./transaction\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n * @group Implementation\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  return getInfoUtil(args);\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 1000).\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  return getModulesUtil(args);\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n * @group Implementation\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  return getModuleUtil(args);\n}\n\n/**\n * Retrieves a list of transactions associated with a specific account address.\n * This function allows you to paginate through the transactions for better performance and usability.\n *\n * @param args - The arguments for retrieving transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The account address for which to retrieve transactions.\n * @param args.options - Optional pagination parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of transactions to retrieve.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves a list of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 999).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      offset: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\n/**\n * Retrieves a specific resource of a given type for the specified account address.\n *\n * @param args - The arguments for retrieving the resource.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account from which to retrieve the resource.\n * @param args.resourceType - The type of the resource to retrieve, specified as a MoveStructId.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @group Implementation\n */\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\n/**\n * Retrieves the original account address associated with a given authentication key, which is useful for handling key rotations.\n *\n * @param args - The arguments for the lookup.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.authenticationKey - The authentication key for which to look up the original address.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @returns The original account address or the provided authentication key address if not found.\n * @throws Throws an error if the lookup fails for reasons other than the address not being found.\n * @group Implementation\n */\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Retrieves the count of tokens owned by a specific account address.\n *\n * @param args - The arguments for retrieving the account tokens count.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to count the tokens.\n * @returns The count of tokens owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\n/**\n * Retrieves the tokens owned by a specified account address.\n *\n * @param args - The arguments for retrieving the account's tokens.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The specific token standard to filter the results.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @returns A promise that resolves to the current token ownerships of the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the tokens owned by a specific account from a particular collection address.\n *\n * @param args - The parameters required to fetch the owned tokens.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.collectionAddress - The address of the collection from which tokens are being retrieved.\n * @param args.options - Optional parameters for filtering and pagination, including token standard, pagination arguments, and\n * order by options.\n * @group Implementation\n */\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the collections owned by a specified account along with the tokens in those collections.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose collections are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - An optional token standard to filter the collections.\n * @param args.options.offset - An optional offset for pagination.\n * @param args.options.limit - An optional limit for the number of results returned.\n * @param args.options.orderBy - An optional parameter to specify the order of the results.\n * @group Implementation\n */\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\n/**\n * Retrieves the count of transactions associated with a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account for which to retrieve the transaction count.\n * @returns The number of transactions associated with the specified account.\n * @group Implementation\n */\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\n/**\n * Retrieves the amount of a specific coin held by an account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account to query.\n * @param args.coinType - Optional; the type of coin to check the amount for.\n * @param args.faMetadataAddress - Optional; the address of the fungible asset metadata.\n * @returns The amount of the specified coin held by the account, or 0 if none is found.\n * @throws Error if neither coinType nor faMetadataAddress is provided.\n * @group Implementation\n */\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n\n  let coinAssetType: string | undefined = coinType;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n    // The paired CoinType should be populated outside of this function in another\n    // async call. We cannot do this internally due to dependency cycles issue.\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinAssetType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\n/**\n * Retrieves the current fungible asset balances for a specified account.\n *\n * @param args - The arguments for retrieving account coins data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve coin data.\n * @param args.options - Optional parameters for pagination and filtering the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @param args.options.where - Conditions to filter the results based on the current fungible asset balances.\n * @group Implementation\n */\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\n/**\n * Retrieves the count of fungible asset coins held by a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve the coin count.\n * @throws Error if the count of account coins cannot be retrieved.\n * @group Implementation\n */\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\n/**\n * Retrieves the objects owned by a specified account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose owned objects are to be retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to the current objects owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Derives an account from the provided private key and Aptos configuration.\n * This function helps in obtaining the account details associated with a given private key,\n * considering both unified and legacy authentication schemes.\n *\n * NOTE: There is a potential issue once the unified single signer scheme is adopted by the community.\n * Because one could create two accounts with the same private key with this new authenticator type,\n * we’ll need to determine the order in which we look up the accounts: first unified scheme and then legacy scheme,\n * or first legacy scheme and then unified scheme.\n *\n * @param args - The arguments for deriving the account.\n * @param args.aptosConfig - The Aptos configuration used for account lookup.\n * @param args.privateKey - The private key used to derive the account.\n * @throws Error if the account cannot be derived from the private key.\n * @group Implementation\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\n/**\n * Checks if an account exists by verifying its information against the Aptos blockchain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.authKey - The authentication key used to derive the account address.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n *\n * @throws Throws an Error if there is an issue while looking for account information.\n * @group Implementation\n */\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Rotates the authentication key for a given account.\n *\n * @param args - The arguments for rotating the authentication key.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.fromAccount - The account from which the authentication key will be rotated.\n * @param args.toAccount - (Optional) The target account to rotate to. Required if not using toNewPrivateKey or toAuthKey.\n * @param args.toNewPrivateKey - (Optional) The new private key to rotate to. Required if not using toAccount or toAuthKey.\n * @param args.toAuthKey - (Optional) The new authentication key to rotate to. Can only be used with dangerouslySkipVerification=true.\n * @param args.dangerouslySkipVerification - (Optional) If true, skips verification steps after rotation. Required when using toAuthKey.\n *\n * @remarks\n * This function supports three modes of rotation:\n * 1. Using a target Account object (toAccount)\n * 2. Using a new private key (toNewPrivateKey)\n * 3. Using a raw authentication key (toAuthKey) - requires dangerouslySkipVerification=true\n *\n * When not using dangerouslySkipVerification, the function performs additional safety checks and account setup.\n *\n * If the new key is a multi key, skipping verification is dangerous because verification will publish the public key onchain and\n * prevent users from being locked out of the account from loss of knowledge of one of the public keys.\n *\n * @returns A promise that resolves to the pending transaction response.\n * @throws Error if the rotation fails or verification fails.\n *\n * @group Implementation\n */\nexport async function rotateAuthKey(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n  } & (\n    | { toAccount: Account; dangerouslySkipVerification?: never }\n    | { toNewPrivateKey: Ed25519PrivateKey; dangerouslySkipVerification?: never }\n    | { toAuthKey: AuthenticationKey; dangerouslySkipVerification: true }\n  ),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, dangerouslySkipVerification } = args;\n  if (\"toNewPrivateKey\" in args) {\n    return rotateAuthKeyWithChallenge({\n      aptosConfig,\n      fromAccount,\n      toNewPrivateKey: args.toNewPrivateKey,\n    });\n  }\n  let authKey: AuthenticationKey;\n  if (\"toAccount\" in args) {\n    if (args.toAccount instanceof Ed25519Account) {\n      return rotateAuthKeyWithChallenge({ aptosConfig, fromAccount, toNewPrivateKey: args.toAccount.privateKey });\n    }\n    if (args.toAccount instanceof MultiEd25519Account) {\n      return rotateAuthKeyWithChallenge({ aptosConfig, fromAccount, toAccount: args.toAccount });\n    }\n    authKey = args.toAccount.publicKey.authKey();\n  } else if (\"toAuthKey\" in args) {\n    authKey = args.toAuthKey;\n  } else {\n    throw new Error(\"Invalid arguments\");\n  }\n\n  const pendingTxn = await rotateAuthKeyUnverified({\n    aptosConfig,\n    fromAccount,\n    toAuthKey: authKey,\n  });\n\n  if (dangerouslySkipVerification === true) {\n    return pendingTxn;\n  }\n\n  const rotateAuthKeyTxnResponse = await waitForTransaction({\n    aptosConfig,\n    transactionHash: pendingTxn.hash,\n  });\n  if (!rotateAuthKeyTxnResponse.success) {\n    throw new Error(`Failed to rotate authentication key - ${rotateAuthKeyTxnResponse}`);\n  }\n\n  // Verify the rotation by setting the originating address to the new account.\n  // This verifies the rotation even if the transaction payload fails to execute successfully.\n  const verificationTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::set_originating_address\",\n      functionArguments: [],\n    },\n  });\n\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: args.toAccount, // Use the new account to sign\n    transaction: verificationTxn,\n  });\n}\n\nasync function rotateAuthKeyWithChallenge(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n  } & ({ toNewPrivateKey: Ed25519PrivateKey } | { toAccount: MultiEd25519Account }),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  let newAccount: Account;\n  if (\"toNewPrivateKey\" in args) {\n    newAccount = Account.fromPrivateKey({ privateKey: args.toNewPrivateKey, legacy: true });\n  } else {\n    newAccount = args.toAccount;\n  }\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n\nconst rotateAuthKeyUnverifiedAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8()],\n};\n\nasync function rotateAuthKeyUnverified(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toAuthKey: AuthenticationKey;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, toAuthKey } = args;\n  const authKey = toAuthKey;\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key_call\",\n      functionArguments: [MoveVector.U8(authKey.toUint8Array())],\n      abi: rotateAuthKeyUnverifiedAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n","// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport {\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n} from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport {\n  EntryFunctionArgumentTypes,\n  SimpleEntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  ViewFunctionABI,\n  FunctionABI,\n  TypeArgument,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isEmptyOption,\n  isString,\n  throwTypeMismatch,\n  convertNumber,\n} from \"./helpers\";\nimport { CallArgument, MoveFunction, MoveModule } from \"../../types\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags.\n *\n * @param typeArguments - An optional array of type arguments that may include string representations.\n * @returns An array of TypeTag objects derived from the provided type arguments.\n * @group Implementation\n * @category Transactions\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeArgument>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: TypeArgument): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI of a specified module from the on-chain module ABI.\n *\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchModuleAbi(\n  moduleAddress: string,\n  moduleName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveModule | undefined> {\n  const moduleBytecode = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n  return moduleBytecode.abi;\n}\n\n/**\n * Fetches the ABI of a specified function from the on-chain module ABI. This function allows you to access the details of a\n * specific function within a module.\n *\n * @param moduleAddress - The address of the module from which to fetch the function ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is to be fetched.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveFunction | undefined> {\n  const moduleAbi = await fetchModuleAbi(moduleAddress, moduleName, aptosConfig);\n  if (!moduleAbi) throw new Error(`Could not find module ABI for '${moduleAddress}::${moduleName}'`);\n  return moduleAbi.exposed_functions.find((func) => func.name === functionName);\n}\n\n/**\n * @deprecated Use `fetchFunctionAbi` instead and manually parse the type tags.\n */\nexport async function fetchMoveFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<FunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n  if (!functionAbi) {\n    throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for an entry function from the specified module address.\n * This function validates if the ABI corresponds to an entry function and retrieves its parameters.\n *\n * @param moduleAddress - The address of the module containing the entry function.\n * @param moduleName - The name of the module containing the entry function.\n * @param functionName - The name of the entry function to fetch the ABI for.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the number of signers, type parameters, and function parameters.\n * @throws Error if the ABI cannot be found or if the function is not an entry function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const numSigners = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = numSigners; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    signers: numSigners,\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for a view function from the specified module address.\n * This function ensures that the ABI is valid and retrieves the type parameters, parameters, and return types for the view function.\n *\n * @param moduleAddress - The address of the module containing the view function.\n * @param moduleName - The name of the module containing the view function.\n * @param functionName - The name of the view function for which to fetch the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the type parameters, parameters, and return types of the view function.\n * @throws Error if the ABI cannot be found or if the function is not a view function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchViewFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<ViewFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find view function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-view functions can't be used\n  if (!functionAbi.is_view) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(functionAbi.return[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n/**\n * @deprecated Handle this inline\n *\n * @example\n * ```typescript\n * const callArgument = argument instanceof CallArgument ? argument : CallArgument.newBytes(\n *   convertArgument(functionName, functionAbi, argument, position, genericTypeParams).bcsToBytes()\n * );\n * ```\n */\nexport function convertCallArgument(\n  argument: CallArgument | EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  functionName: string,\n  functionAbi: FunctionABI,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): CallArgument {\n  if (argument instanceof CallArgument) {\n    return argument;\n  }\n  return CallArgument.newBytes(\n    convertArgument(functionName, functionAbi, argument, position, genericTypeParams).bcsToBytes(),\n  );\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary.\n * This function checks the provided argument against the expected parameter type and converts it accordingly.\n *\n * @param functionName - The name of the function for which the argument is being converted.\n * @param functionAbiOrModuleAbi - The ABI (Application Binary Interface) of the function, which defines its parameters.\n * @param arg - The argument to be converted, which can be of various types.\n * @param position - The index of the argument in the function's parameter list.\n * @param genericTypeParams - An array of type tags for any generic type parameters.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbiOrModuleAbi: MoveModule | FunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  let param: TypeTag;\n\n  if (\"exposed_functions\" in functionAbiOrModuleAbi) {\n    const functionAbi = functionAbiOrModuleAbi.exposed_functions.find((func) => func.name === functionName);\n    if (!functionAbi) {\n      throw new Error(\n        `Could not find function ABI for '${functionAbiOrModuleAbi.address}::${functionAbiOrModuleAbi.name}::${functionName}'`,\n      );\n    }\n\n    if (position >= functionAbi.params.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.params.length}`);\n    }\n\n    param = parseTypeTag(functionAbi.params[position], { allowGenerics: true });\n  } else {\n    if (position >= functionAbiOrModuleAbi.parameters.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbiOrModuleAbi.parameters.length}`);\n    }\n\n    param = functionAbiOrModuleAbi.parameters[position];\n  }\n\n  return checkOrConvertArgument(\n    arg,\n    param,\n    position,\n    genericTypeParams,\n    \"exposed_functions\" in functionAbiOrModuleAbi ? functionAbiOrModuleAbi : undefined,\n    options,\n  );\n}\n\n/**\n * Checks if the provided argument is BCS encoded and converts it if necessary, ensuring type compatibility with the ABI.\n * This function helps in validating and converting arguments for entry functions based on their expected types.\n *\n * @param arg - The argument to check or convert, which can be either a simple or entry function argument type.\n * @param param - The expected type tag for the argument.\n * @param position - The position of the argument in the function call.\n * @param genericTypeParams - An array of generic type parameters that may be used for conversion.\n * @group Implementation\n * @category Transactions\n */\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n\n    /**\n     * Checks the type of the provided argument against the expected type.\n     * This function helps validate that the argument conforms to the specified type requirements.\n     *\n     * @param typeArgs - The expected type arguments.\n     * @param arg - The argument to be checked.\n     * @param position - The position of the argument in the context of the check.\n     * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n     *                    This will typically have information about structs, enums, and other types.\n     * @group Implementation\n     * @category Transactions\n     */\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams, moduleAbi, options);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively.\n * This function helps convert various types of input arguments into their corresponding BCS encoded formats based on the\n * specified parameter type.\n *\n * @param arg - The argument to be parsed, which can be of various types.\n * @param param - The type tag that defines the expected type of the argument.\n * @param position - The position of the argument in the function call, used for error reporting.\n * @param genericTypeParams - An array of type tags for generic type parameters, used when the parameter type is generic.\n * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n *                    This will typically have information about structs, enums, and other types.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    if (isString(arg)) {\n      if (arg === \"true\") return new Bool(true);\n      if (arg === \"false\") return new Bool(false);\n    }\n\n    /**\n     * Throws a type mismatch error for the specified move option.\n     *\n     * @param moveOption - The name of the move option that caused the type mismatch.\n     * @param position - The position where the error occurred.\n     * @group Implementation\n     * @category Transactions\n     */\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U8(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU16()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U16(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU32()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U32(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the subtype\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams, moduleAbi);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 Uint8Array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    if (isString(arg)) {\n      // In a web env, arguments are passing as strings\n      if (arg.startsWith(\"[\")) {\n        return checkOrConvertArgument(JSON.parse(arg), param, position, genericTypeParams);\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(\n        arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams, moduleAbi)),\n      );\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n    // Handle known enum types from Aptos framework\n    if (param.isDelegationKey() || param.isRateLimiter()) {\n      if (arg instanceof Uint8Array) {\n        return new FixedBytes(arg);\n      }\n      throwTypeMismatch(\"Uint8Array\", position);\n    }\n\n    if (param.isOption()) {\n      if (isEmptyOption(arg)) {\n        // Here we attempt to reconstruct the underlying type\n        // Note, for some reason the `isBool` etc. does not work with the compiler\n        const innerParam = param.value.typeArgs[0];\n        if (innerParam instanceof TypeTagBool) {\n          return new MoveOption<Bool>(null);\n        }\n        if (innerParam instanceof TypeTagAddress) {\n          return new MoveOption<AccountAddress>(null);\n        }\n        if (innerParam instanceof TypeTagU8) {\n          return new MoveOption<U8>(null);\n        }\n        if (innerParam instanceof TypeTagU16) {\n          return new MoveOption<U16>(null);\n        }\n        if (innerParam instanceof TypeTagU32) {\n          return new MoveOption<U32>(null);\n        }\n        if (innerParam instanceof TypeTagU64) {\n          return new MoveOption<U64>(null);\n        }\n        if (innerParam instanceof TypeTagU128) {\n          return new MoveOption<U128>(null);\n        }\n        if (innerParam instanceof TypeTagU256) {\n          return new MoveOption<U256>(null);\n        }\n\n        // In all other cases, we will use a placeholder, it doesn't actually matter what the type is, but it will be obvious\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<MoveString>(null);\n      }\n\n      return new MoveOption(\n        checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams, moduleAbi),\n      );\n    }\n\n    // We are assuming that fieldless structs are enums, and therefore we cannot typecheck any further due\n    // to limited information from the ABI. This does not work for structs on other modules.\n    const structDefinition = moduleAbi?.structs.find((s) => s.name === param.value.name.identifier);\n    if (structDefinition?.fields.length === 0 && arg instanceof Uint8Array) {\n      return new FixedBytes(arg);\n    }\n\n    if (arg instanceof Uint8Array && options?.allowUnknownStructs) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        // eslint-disable-next-line max-len\n        `Unsupported struct input type for argument ${position}. Continuing since 'allowUnknownStructs' is enabled.`,\n      );\n      return new FixedBytes(arg);\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of the BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n * @group Implementation\n * @category Transactions\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n"],"mappings":"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","names":["sha3Hash","generateTransactionPayload","args","isScriptDataInput","generateTransactionPayloadScript","moduleAddress","moduleName","functionName","getFunctionParts","functionAbi","fetchAbi","fetchEntryFunctionAbi","generateTransactionPayloadWithABI","typeArguments","standardizeTypeTags","functionArguments","arg","i","convertArgument","entryFunctionPayload","EntryFunction","multisigAddress","AccountAddress","TransactionPayloadMultiSig","MultiSig","MultiSigTransactionPayload","TransactionPayloadEntryFunction","generateViewFunctionPayload","fetchViewFunctionAbi","generateViewFunctionPayloadWithABI","TransactionPayloadScript","Script","Hex","generateRawTransaction","aptosConfig","sender","payload","options","feePayerAddress","getChainId","NetworkToChainId","getLedgerInfo","getGasUnitPrice","getGasPriceEstimation","getSequenceNumberForAny","getSequenceNumber","getInfo","chainId","gasEstimate","sequenceNumber","maxGasAmount","gasUnitPrice","expireTimestamp","RawTransaction","ChainId","buildTransaction","rawTxn","signers","signer","MultiAgentTransaction","SimpleTransaction","generateSignedTransactionForSimulation","signerPublicKey","transaction","secondarySignersPublicKeys","feePayerPublicKey","accountAuthenticator","getAuthenticatorForSimulation","transactionToSign","FeePayerRawTransaction","secondaryAccountAuthenticators","publicKey","feePayerAuthenticator","transactionAuthenticator","TransactionAuthenticatorFeePayer","SignedTransaction","MultiAgentRawTransaction","TransactionAuthenticatorMultiAgent","AccountAuthenticatorEd25519","TransactionAuthenticatorEd25519","AccountAuthenticatorSingleKey","AccountAuthenticatorMultiKey","TransactionAuthenticatorSingleSender","AccountAuthenticatorNoAccountAuthenticator","accountPublicKey","KeylessPublicKey","FederatedKeylessPublicKey","Secp256k1PublicKey","AnyPublicKey","invalidSignature","Ed25519Signature","Ed25519PublicKey","AnySignature","KeylessSignature","MultiKey","MultiKeySignature","pubKey","_","generateSignedTransaction","additionalSignersAuthenticators","senderAuthenticator","normalizeBundle","AccountAuthenticator","txnAuthenticator","AccountAuthenticatorMultiEd25519","TransactionAuthenticatorMultiEd25519","hashValues","input","hash","sha3Hash","item","TRANSACTION_PREFIX","generateUserTransactionHash","signedTransaction","key","abi","fetch","memoizeAsync","ScriptComposerWasm","AptosScriptComposer","_AptosScriptComposer","aptosConfig","module","TransactionComposer","initSync","ScriptComposerWasm","input","moduleAddress","moduleName","functionName","getFunctionParts","nodeUrl","typeArgument","typeArguments","standardizeTypeTags","moduleAbi","fetchModuleAbi","functionAbi","func","functionArguments","arg","i","CallArgument","convertArgument","generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","aptosConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessageForTransaction","signTransaction","signer","signAsFeePayer","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","e","signedTxn","SignedTransaction","Deserializer","KeylessPublicKey","FederatedKeylessPublicKey","AbstractKeylessAccount","signAndSubmitTransaction","feePayer","isKeylessSigner","feePayerAuthenticator","senderAuthenticator","signAndSubmitAsFeePayer","packagePublishAbi","TypeTagVector","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","getInfo","args","getModules","getModule","getTransactions","aptosConfig","accountAddress","options","paginateWithCursor","AccountAddress","getResources","paginateWithObfuscatedCursor","getResource","resourceType","data","getAptosFullNode","lookupOriginalAccountAddress","authenticationKey","resource","handle","authKeyAddress","originalAddress","getTableItem","err","AptosApiError","getAccountTokensCount","whereCondition","queryIndexer","GetAccountTokensCount","getAccountOwnedTokens","graphqlQuery","GetAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","GetAccountOwnedTokensFromCollection","getAccountCollectionsWithOwnedTokens","GetAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","address","GetAccountTransactionsCount","getAccountCoinAmount","coinType","faMetadataAddress","coinAssetType","faAddress","APTOS_COIN","createObjectAddress","addr","where","getAccountCoinsData","GetAccountCoinsData","getAccountCoinsCount","GetAccountCoinsCount","getAccountOwnedObjects","GetObjectData","deriveAccountFromPrivateKey","privateKey","publicKey","AnyPublicKey","Secp256k1PrivateKey","AuthenticationKey","Account","Ed25519PrivateKey","singleSenderTransactionAuthenticatorAuthKey","isAccountExist","legacyAuthKey","authKey","error","rotateAuthKeyAbi","TypeTagU8","TypeTagVector","rotateAuthKey","fromAccount","dangerouslySkipVerification","rotateAuthKeyWithChallenge","Ed25519Account","MultiEd25519Account","pendingTxn","rotateAuthKeyUnverified","rotateAuthKeyTxnResponse","waitForTransaction","verificationTxn","generateTransaction","signAndSubmitTransaction","accountInfo","newAccount","challengeHex","RotationProofChallenge","proofSignedByCurrentKey","proofSignedByNewKey","rawTxn","U8","MoveVector","rotateAuthKeyUnverifiedAbi","toAuthKey","TEXT_ENCODER","standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchModuleAbi","moduleAddress","moduleName","aptosConfig","getModule","fetchFunctionAbi","functionName","moduleAbi","func","fetchMoveFunctionAbi","functionAbi","params","i","fetchEntryFunctionAbi","numSigners","findFirstNonSignerArg","fetchViewFunctionAbi","returnTypes","convertCallArgument","argument","position","genericTypeParams","CallArgument","convertArgument","functionAbiOrModuleAbi","arg","options","param","checkOrConvertArgument","isEncodedEntryFunctionArgument","checkType","parseArg","isBool","Bool","throwTypeMismatch","AccountAddress","num","convertNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","MoveVector","item","MoveString","FixedBytes","isEmptyOption","innerParam","TypeTagBool","MoveOption","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","s","isBcsBool","isBcsAddress","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","TypeTagStruct","isBcsString"]}